package cn.locusc.java8action.chapter13FunctionalReflection;

import cn.locusc.java8action.domain.Apple;
import cn.locusc.java8action.domain.Dish;

import java.util.*;
import java.util.stream.LongStream;

/**
 * @author Jay
 * 本章内容:
 *  为什么要进行函数式编程
 *  什么是函数式编程
 *  声明式编程以及引用透明性
 *  编写函数式Java的准则
 *  迭代和递归
 * 小结:
 *  从长远看，减少共享的可变数据结构能帮助你降低维护和调试程序的代价。
 *  函数式编程支持无副作用的方法和声明式编程。
 *  函数式方法可以由它的输入参数及输出结果进行判断。
 *  如果一个函数使用相同的参数值调用，总是返回相同的结果，那么它是引用透明的。采
 * 用递归可以取得迭代式的结构，比如while循环。
 *  相对于Java语言中传统的递归，“尾-递”可能是一种更好的方式，它开启了一扇门，让我
 * 们有机会最终使用编译器进行优化。
 * 2021/12/1
 */
public class ActionClass {

    /**
     * 13.1 实现和维护系统
     * 首先会探究函数式编程背后的概念，
     * 比如副作用、不变性、声明式编程、引用透明性，并将它们和Java 8的实践相结合
     *
     * 我们希望程序望它具有良好的结构，最好类的结构应该反映出系统的结构
     * 软件工程中还提供了指标，对结构的合理性进行评估，比如耦合性（软件系统中各组件之间是否相互独立）
     * 以及内聚性（系统的各相关部分之间如何协作）。
     */
    public static class Jia131 {

        /**
         * 13.1.1 共享的可变数据
         * 问题:讨论的无法预知的变量修改问题，都源于共享的数据结构被你所维护的代码中的多个方法读取和更新
         * 思考:
         * 1.假设几个类同时都保存了指向某个列表的引用。那么到底谁对这个列表拥有所属权呢
         * 2.如果一个类对它进行了修改，会发生什么情况
         * 3.其他的类预期会发生这种变化吗
         * 4.其他的类又如何得知列表发生了修改呢
         * 5.我们需要通知使用该列表的所有类这一变化吗
         * 6.抑或是不是每个类都应该为自己准备一份防御式的数据备份以备不时之需呢
         * 换句话说，由于使用了可变的共享数据结构，我们很难追踪你程序的各个组成部分所发生的变化
         *
         * 如果一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，
         * 使用return返回所有的计算结果，那么我们称其为纯粹的或者无副作用的
         */
        public static class Jia1311 {

            public static void main(String[] args) {

                // 到底那些因素会造成副作用
                // 副作用就是函数的效果已经超出了函数自身的范畴
                //  除了构造器内的初始化操作，对类中数据结构的任何修改，包括字段的赋值操作（一个
                // 典型的例子是setter方法）。
                //  抛出一个异常。
                //  进行输入/输出操作，比如向一个文件写数据。

                //从另一个角度来看“无副作用”的话，我们就应该考虑不可变对象。不可变对象是这样一种
                //对象，它们一旦完成初始化就不会被任何方法修改状态。这意味着一旦一个不可变对象初始化完
                //毕，它永远不会进入到一个无法预期的状态。你可以放心地共享它，无需保留任何副本，并且由
                //于它们不会被修改，还是线程安全的。
                //“无副作用”这个想法的限制看起来很严苛，你甚至可能会质疑是否有真正的生产系统能够
                //以这种方式构建。我们希望结束本章的学习之后，你能够确信这一点。一个好消息是，如果构成
                //系统的各个组件都能遵守这一原则，该系统就能在完全无锁的情况下，使用多核的并发机制，因
                //为任何一个方法都不会对其他的方法造成干扰。此外，这还是一个让你了解你的程序中哪些部分
                //是相互独立的非常棒的机会。
            }
        }

        /**
         * 13.1.2 声明式编程
         * 一般通过编程实现一个系统，有两种思考方式。一种专注于如何实现，比如：“首先做这个，
         * 紧接着更新那个，然后……”
         * 这种“如何做”风格的编程非常适合经典的面向对象编程，有些时候我们也称之为“命令式”
         * 编程，因为它的特点是它的指令和计算机底层的词汇非常相近，比如赋值、条件分支以及循环
         */
        public static class Jia1312 {

            public static void main(String[] args) {
//                Transaction mostExpensive = transactions.get(0);
//                if(mostExpensive == null)
//                 throw new IllegalArgumentException("Empty list of transactions")
//                for(Transaction t: transactions.subList(1, transactions.size())){
//                 if(t.getValue() > mostExpensive.getValue()){
//                 mostExpensive = t;
//                 }
//                }

                // 专注于如何实现
                // 书中没有Transaction实体 这里使用Dish代替
                List<Dish> transactions = Dish.getDish();
                Dish mostExpensive = transactions.get(0);
                if(mostExpensive == null) {
                    throw new IllegalArgumentException("Empty list of transactions");
                }

                for(Dish t: transactions.subList(1, transactions.size())){
                    if(t.getCalories() > mostExpensive.getCalories()){
                        mostExpensive = t;
                    }
                }

                // 另一种方式则更加关注要做什么。
                // 这个查询把最终如何实现的细节留给了函数库。我们把这种思想称之为内部迭代
                // 它的巨大优势在于你的查询语句现在读起来就像是问题陈述
                // 采用这种“要做什么”风格的编程通常被称为声明式编程
                // 你制定规则，给出了希望实现的目标，让系统来决定如何实现这个目标。用这种方式编写的代码更加接近问题陈述了。
                Optional<Dish> max = transactions.stream().max(Comparator.comparing(Dish::getCalories));
            }
        }

        /**
         * 13.1.3 为什么要采用函数式编程
         * 函数式编程具体实践了前面介绍的声明式编程（“你只需要使用不相互影响的表达式，描述
         * 想要做什么，由系统来选择如何实现”）和无副作用计算。
         *
         * 第3章中使用Lambda表达式介绍的内容，即一些语言的特性，比如构
         * 造操作和传递行为对于以自然的方式实现声明式编程是必要的
         * 以使用Stream将几个操作串接在一起，表达一个复杂的查询。这些都是函数式编程语言的特性；
         */
        public static class Jia1313 { }
    }

    /**
     * 13.2 什么是函数式编程
     * 最简化的回答是“它是一种使用函数进行编程的方式
     * 什么是函数？
     * 想象这样一个方法，它接受一个整型和一个浮点型参数，返回一个浮点型的结
     * 果——它也有副作用，随着调用次数的增加，它会不断地更新共享变量，如图【带有副作用的函数.png】
     *
     * 在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生
     * 成一个或多个结果，并且不会有任何副作用。你可以把它看成一个黑盒，它接收输入并产生一些
     * 输出，如图【一个没有任何副作用的函数】。
     *
     * 这种类型的函数和你在Java编程语言中见到的函数之间的区别是非常重要的（我们无法想
     * 象，log或者 sin这样的数学函数会有副作用）。尤其是，使用同样的参数调用数学函数，它所返
     * 回的结果一定是相同的。这里，我们暂时不考虑Random.nextInt这样的方法
     *
     * 当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”。由此，编程
     * 上的一些精妙问题随之而来。我们的意思是，每个函数都只能使用函数和像if-then-else这样
     * 的数学思想来构建吗？或者，我们也允许函数内部执行一些非函数式的操作，只要这些操作的结
     * 果不会暴露给系统中的其他部分？换句话说，如果程序有一定的副作用，不过该副作用不会为其
     * 他的调用者感知，是否我们能假设这种副作用不存在呢？调用者不需要知道，或者完全不在意这
     * 些副作用，因为这对它完全没有影响。
     * 当我们希望能界定这二者之间的区别时，我们将第一种称为纯粹的函数式编程（在本章的最
     * 后会讨论这部分内容），后者称为函数式编程。
     */
    public static class Jia132 {

        /**
         * 13.2.1 函数式 Java 编程
         * 被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的
         * 对象都应该是不可修改的对象。通过这种规定，我们期望所有的字段都为final类型，
         * 所有的引用类型字段都指向不可变对象
         *
         * 要被称为函数式，函数或者方法不应该抛出任何异常
         * 这里存在着一定的争执，有的作者认为抛出代表严重错误的异常是可以接受的，但是捕获异常是一种非函数式的控制流，因为
         * 这种操作违背了我们在黑盒模型中定义的“传递参数，返回结果”的规则，引出了代表异常处
         * 理的第三支箭头，如图【抛出一个异常的方法.png】
         * 那么，如果不使用异常，你该如何对除法这样的函数进行建模呢？答案是请使用
         * Optional<T>类型：你应该避免让sqrt使用double sqrt(double)这样的函数签名，因为这
         * 种方式可能抛出异常；与之相反我们推荐你使用Optional<Double> sqrt(double)——这种
         * 方式下，函数要么返回一个值表示调用成功，要么返回一个对象，表明其无法进行指定的操作。
         * 当然，这意味着调用者需要检查方法返回的是否为一个空的Optional对象。这件事听起来代价
         * 不小，依据我们之前对函数式编程和纯粹的函数式编程的比较，从实际操作的角度出发，你可以
         * 选择在本地局部地使用异常，避免通过接口将结果暴露给其他方法，这种方式既取得了函数式的
         * 优点，又不会过度膨胀代码。
         * 最后，作为函数式的程序，你的函数或方法调用的库函数如果有副作用，你必须设法隐藏它
         * 们的非函数式行为，否则就不能调用这些方法（换句话说，你需要确保它们对数据结构的任何修
         * 改对于调用者都是不可见的，你可以通过首次复制，或者捕获任何可能抛出的异常实现这一目
         * 的）。在13.2.4节中，你会看到这样的例子，我们通过复制列表的方式，有效地隐藏了方法
         * insertAll调用库函数List.add所产生的副作用。
         * 这些方法通常会使用注释或者使用标记注释声明的方式进行标注——符合我们规定的函数，
         * 我们可以将其作为参数传递给并发流处理操作，比如我们在第4~7章介绍过的Stream.map方法。
         */
        public static class Jia1321 { }

        /**
         * 13.2.2 引用透明性
         * “没有可感知的副作用”（不改变对调用者可见的变量、不进行I/O、不抛出异常）的这些限
         * 制都隐含着引用透明性。如果一个函数只要传递同样的参数值，总是返回同样的结果，那这个
         * 函数就是引用透明的
         * 换句话说，函数无论在何处、何时调用，如果使用同样的输入总能持续地得到相同的结果，
         * 就具备了函数式的特征。这也解释了我们为什么不把Random.nextInt看成函数式的方法。Java
         * 语言中，使用Scanner对象从用户的键盘读取输入也违反了引用透明性原则，因为每次调用
         * nextLine时都可能得到不同的结果。不过，将两个final int类型的变量相加总能得到同样的
         * 结果，因为在这种声明方式下，变量的内容是不会被改变的。
         * 引用透明性是理解程序的一个重要属性。它还包含了对代价昂贵或者需长时间计算才能得到
         * 结果的变量值的优化（通过保存机制而不是重复计算），我们通常将其称为记忆化或者缓存。虽
         * 然重要，但是现在讨论还是有些跑题，我们会在14.5节进行介绍。
         * Java语言中，关于引用透明性还有一个比较复杂的问题。假设你对一个返回列表的方法调用
         * 了两次。这两次调用会返回内存中的两个不同列表，不过它们包含了相同的元素。如果这些列表
         * 被当作可变的对象值（因此是不相同的），那么该方法就不是引用透明的。如果你计划将这些列
         * 表作为单纯的值（不可修改），那么把这些值看成相同的是合理的，这种情况下该方法是引用透
         * 明的。通常情况下，在函数式编程中，你应该选择使用引用透明的函数。我们会在14.5节继续讨
         * 论这一主题。现在我们想探讨从更大的范围看是否应该修改对象的值。
         */
        public static class Jia1322 { }

        /**
         * 13.2.3 面向对象的编程和函数式编程的对比
         * 我们由函数式编程和（极端）典型的面向对象编程的对比入手进行介绍，最终你会发现Java
         * 8认为这些风格其实只是面向对象的一个极端
         * 由于硬件（比如多核）和程序员期望（比如使用类数据库查询式的语言去操纵数据）的变化，
         * 促使Java的软件工程风格在某种程度上愈来愈向函数式的方向倾斜，
         *
         * 关于这个问题有两种观点。一种支持极端的面向对象：任何事物都是对象，程序要么通过更
         * 新字段完成操作，要么调用对与它相关的对象进行更新的方法。另一种观点支持引用透明的函数
         * 式编程，认为方法不应该有（对外部可见的）对象修改。实际操作中，Java程序员经常混用这些
         * 风格。你可能会使用包含了可变内部状态的迭代器遍历某个数据结构，同时又通过函数式的方式
         * （我们曾经讨论过，可以使用可变局部变量实现这一目标）计算数据结构中的变量之和。本章接
         * 下来的一节以及下一章中主要的内容都围绕这函数式编程的技巧展开，帮助你编写更加模块化，
         * 更适应多核处理器的应用程序。这些技巧和思想会成为你编程武器库中的秘密武器。
         */
        public static class Jia1323 { }

        /**
         * 13.2.4 函数式编程实战
         * 给定一个列表List<value>，比如{1, 4,
         * 9}，构造一个List<List<Integer>>，它的成员都是类表{1, 4, 9}的子集——我们暂时不考虑
         * 元素的顺序。{1, 4, 9}的子集是{1, 4, 9}、{1, 4}、{1, 9}、{4, 9}、{1}、{4}、{9}以及{}。
         * 包括空子集在内，这样的子集总共有8个。每个子集都使用List<Integer>表示，这就是答
         * 案中期望的List<List<Integer>>类型。
         *
         * 对于“{1, 4, 9}的子集可以划分为包含1和不包含
         * 1的两部分”也需要特别解释①。不包含1的子集很简单就是{4, 9}，包含1的子集可以通过将1插入
         * 到{4, 9}的各子集得到。这样我们就能利用Java，以一种简单、自然、自顶向下的函数式编程方
         * 式实现该程序了（一个常见的编程错误是认为空的列表没有子集）。
         */
        public static class Jia1324 {

            public static List<List<Integer>> subsets(List<Integer> list) {
                if(list.isEmpty()) {
                    // 如果输入为空 它就只包含一个子集 既空列表自身
                    ArrayList<List<Integer>> ans = new ArrayList<>();
                    ans.add(Collections.emptyList());
                    return ans;
                }

                Integer first = list.get(0);
                List<Integer> rest = list.subList(1, list.size());

                // 否则就取出一个元素first找出剩余部分的所有子集，
                // 并将其赋予subans。subans构成了结果的另外一半
                List<List<Integer>> subans = subsets(rest);
                // 答案的另一半是 subans2 ，它包含了subans中的所有列表，但是经过调整，在
                // 每个列表的第一个元素之前添加了first
                List<List<Integer>> subans2 = insertAll(first, subans);
                // 将两个子答案整合在一起就完成了任务
                return concat(subans, subans2);
            }


            public static List<List<Integer>> insertAll(Integer first,
                                                        List<List<Integer>> lists) {
                // 创建了一个新的List，它包含了subans的所有元素
                List<List<Integer>> result = new ArrayList<>();
                for (List<Integer> list : lists) {
                    // 复制列表，从而使你有机会对其进行添加操作。即使底层是可变的
                    // 你也不应该复制底层的结构（不过Integer底层是不可变的）
                    List<Integer> copyList = new ArrayList<>();
                    copyList.add(first);
                    copyList.addAll(list);
                    result.add(copyList);
                }
                // 利用了Integer对象无法修改这一优势，否则你需要为每个元素创建一个副本
                // insertAll像函数式那样地工作，你很自然地将所有的复制操作放到了insertAll中，
                // 而不是它的调用者中
                return result;
            }


            // 与此相反，第一个版本基于这样的事实，执行完concat(subans, subans2)方法调用后
            // 对于我们定义的subsets，这的确是事实，所以使用简化版本的concat是个不错的选择。
            public static  List<List<Integer>> concatMistake(List<List<Integer>> a,
                                                      List<List<Integer>> b) {
                a.addAll(b);
                return a;
            }

            // 第二个版本的concat是纯粹的函数式。虽然它在内部会对对象进行修改
            // （向列表r添加元素），但是它返回的结果基于参数却没有修改任何一个传入的参数
            public static  List<List<Integer>> concat(List<List<Integer>> a,
                                                             List<List<Integer>> b) {
                List<List<Integer>> r = new ArrayList<>(a);
                r.addAll(b);
                return r;
            }

            // 考虑编程问题时，采用函数式的方法，关注函数的输入参数以及输出结果（即你希
            //望做什么），通常比设计阶段的早期就考虑如何做、修改哪些东西要卓有成效得多。我们现在转
            //入介绍更深入的递归，它是函数式编程特别推崇的一种技术，能帮你更深刻地理解“做什么”这一风格。
            public static void main(String[] args) {
                System.out.println(subsets(Arrays.asList(1, 2)));
            }
        }
    }

    /**
     * 13.3 递归和迭代
     */
    public static class Jia133 {

        //纯粹的函数式编程语言通常不包含像while或者for这样的迭代构造器。为什么呢？因为这
        //种类型的构造器经常隐藏着陷阱，诱使你修改对象。比如，while循环中，循环的条件需要更新；
        //否则循环就一次都不会执行，要么就进入无限循环的状态。但是，很多情况下循环还是非常有用
        //的。我们在前面的介绍中已经声明过，如果没有人能感知的话，函数式也允许进行变更，这意味
        //着我们可以修改局部变量。我们在Java中使用的for-each循环，for(Apple a : apples { }
        //如果用迭代器方式重写，
        //这并不是问题，因为改变发生时，这些变化（包括使用next方法对迭代器状态的改变以及
        //在while循环内部对apple变量的赋值）对于方法的调用方是不可见的
        public void pureIterator() {
            Iterator<Apple> it = Apple.getApples().iterator();
            while (it.hasNext()) {
                Apple next = it.next();
                // ...
            }
        }

        //但是，如果使用for-each循环，比如像下面这个搜索算法就会带来问题，
        //因为循环体会对调用方共享的数据结构进行修改
        //实际上，对函数式而言，循环体带有一个无法避免的副作用：它会修改stats对象的状态，
        //而这和程序的其他部分是共享的
//        public void searchForGold(List<String> l, Stats stats){
//            for(String s: l){
//                if("gold".equals(s)){
//                    stats.incrementFor("gold");
//                }
//            }
//        }

        //比较理论的答案是每个程序都能使用无需修改的递归重写，通过这种方
        //式避免使用迭代。使用递归，你可以消除每步都需更新的迭代变量。一个经典的教学问题是用迭
        //代的方式或者递归的方式（假设输入值大于1）编写一个计算阶乘的函数（参数为正数），代码列
        //表如下。
        // 第一段代码展示了标准的基于循环的结构：变量r和i在每轮循环中都会被更新
        // 迭代式的阶乘计算
        public static int factorialIterative(int n) {
            int r = 1;
            for (int i = 1; i <= n; i++) {
                r *= i;
            }
            return r;
        }

        // 递归式的阶乘计算
        // 第二段代码以更加类数学的形式给出一个递归方法（方法调用自身）的实现。
        public static long factorialRecursive(long n) {
            return n == 1 ? 1 : n * factorialRecursive(n);
        }

        // 基于Stream的阶乘
        public static long factorialStreams(long n) {
            return LongStream.rangeClosed(1, n)
                    .reduce(1, (long a, long b) -> a * b);
        }

        //通常而言，执行一次递归式方法调用的
        //开销要比迭代执行单一机器级的分支指令大不少。为什么呢？每次执行factorialRecursive
        //方法调用都会在调用栈上创建一个新的栈帧，用于保存每个方法调用的状态（即它需要进行的乘
        //法运算），这个操作会一直指导程序运行直到结束。这意味着你的递归迭代方法会依据它接收的
        //输入成比例地消耗内存。这也是为什么如果你使用一个大型输入执行factorialRecursive方
        //法，很容易遭遇StackOverflowError异常

        //函数式语言提供了一种方法解决这一问题：尾-
        //调优化（tail-call optimization）。基本的思想是你可以编写阶乘的一个迭代定义，不过迭代调用发
        //生在函数的最后（所以我们说调用发生在尾部）。这种新型的迭代调用经过优化后执行的速度快
        //很多。作为示例，下面是一个阶乘的“尾-递”（tail-recursive）定义
        // 基于“尾-递”的阶乘
        private static long factorialTailRecursive(long n) {
            return factorialHelper(1, n);
        }

        //方法factorialHelper属于“尾递”类型的函数，原因是递归调用发生在方法的最后。对
        //比我们前文中factorialRecursive方法的定义，这个方法的最后一个操作是乘以n，从而得到
        //递归调用的结果。
        //这种形式的递归是非常有意义的，现在我们不需要在不同的栈帧上保存每次递归计算的中间
        //值，编译器能够自行决定复用某个栈帧进行计算。实际上，在factorialHelper的定义中，立
        //即数（阶乘计算的中间结果）直接作为参数传递给了该方法。再也不用为每个递归调用分配单独
        //的栈帧用于跟踪每次递归调用的中间值——通过方法的参数能够直接访问这些值
        private static long factorialHelper(long acc, long n) {
            return n == 1 ? acc : factorialHelper(acc * n, n - 1);
        }

        //坏消息是，目前Java还不支持这种优化。但是使用相对于传统的递归，“尾递”可能是更好
        //的一种方式，因为它为最终实现编译器优化开启了一扇门。很多的现代JVM语言，比如Scala和
        //Groovy都已经支持对这种形式的递归的优化，最终实现的效果和迭代不相上下（它们的运行速
        //度几乎是相同的）。这意味着坚持纯粹函数式既能享受它的纯净，又不会损失执行的效率。
        //使用Java 8进行编程时，我们有一个建议，你应该尽量使用Stream取代迭代操作，从而避免
        //变化带来的影响。此外，如果递归能让你以更精炼，并且不带任何副作用的方式实现算法，你就
        //应该用递归替换迭代。实际上，我们看到使用递归实现的例子更加易于阅读，同时又易于实现和
        //理解（比如，我们在前文中展示的子集的例子），大多数时候编程的效率要比细微的执行时间差
        //异重要得多。
        //这一节，我们讨论了函数式编程，但仅仅是初步介绍了函数式方法的思想——我们介绍的内
        //容甚至适用于最早版本的Java。接下来的一章，我们会讨论Java 8携眷着的一类函数具备了哪些
        //让人耳目一新的强大能力。
    }

}
