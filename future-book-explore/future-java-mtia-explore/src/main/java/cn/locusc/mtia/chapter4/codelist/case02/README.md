下面看一个实战案例。某分布式电信系统（以下简称“该系统”)需要一款统计工具，
用于从指定的接口日志文件中统计出外部系统(部件）处理指定请求（操作)的响应延时(即从该系统给指定外部系统发送请求到该系统接收到相应响应之间的时间差）情况。
接口日志文件格式如下:
操作时间戳（UTC 时间)|协议类型( SOAP/REST/HTTP)|记录类型（请求/响应)|接口名称|操作名称|源设备名|目标设备名|消息唯一标识( traceld)|本机IP地址|主叫号码|

响应延时统计的算法如下:
以一定的时间（如10s ）为周期，然后将请求时间落在该周期内的指定请求的响应延时累加起来。
在输出统计结果的时候，我们只需要逐个地将各个周期的响应延时累加值除以周期长度就可以得到该周期内的平均响应延时。
对于单条请求的响应延时我们可以采用这种方法计算:在读取到一个表示请求的日志记录时记录下相应请求的消息唯一标识( traceld )、
请求时间戳，然后读取到一条表示响应的日志记录时，根据指定的消息唯一标识差值( traceldDiff，如 3)计算出与该响应记录对应的请求记录的消息唯一标识，
凭此消息唯一标识找到之前存储的请求时间戳,通过计算该响应记录的时间戳与相应的请求时间戳之差就可以得到单条请求的响应延时。

一个接口日志文件最多可以包含1万条记录,而我们可能需要从指定的上百个这样的文件进行统计，
即统计程序的输人规模（记录条数)可能达到几百万甚至上千万。
为了尽量提高统计的效率，这个问题乍一看似乎可以使用4.3节我们提到的基于数据的分割。
例如，假设指定的接口日志文件个数为400个，那么我们可以考虑指定4个线程，其中每个线程负责对指定日志文件中的100个文件进行统计，
即这些工作者线程各自逐条读取100个文件中的记录，再根据记录中的数据按照上述算法进行统计。

但是这样做也存在以下几个问题。
问题1增加程序的复杂性:由于代表一对请求和响应的两条日志记录可能被分别存储在两个日志文件中，
因此多个工作者线程并发地读取日志文件的时候可能出现代表响应的日志记录先被读取，而代表相应请求的日志记录后被读取。这样一来实现上述算法就有些困难。

问题2可能导致I/O资源争用增加而减低I/O效率:机械式硬盘在顺序读取文件(读取完一个文件接着再读取另外一个文件)的时候效率会比较高,
而多个工作者线程并发地读取多个文件可能反而会降低文件读取的效率。

问题3可能导致处理器时间的浪费:一个工作者线程在等待磁盘返回数据的期间，该线程是处于暂停(WAITING)状态的，它无法执行其他计算，从而导致处理器时间的浪费。
由此可见，在该案例中直接使用基于数据的分割是不太合适的。因此，我们不妨先考虑一下单线程的实现方式。为了便于评估其他的实现方案（比如其他方法实现的多线程版)，
我们对这个统计程序的算法步骤进行了抽象，如清单4-5所示。


