9.1同步计算与异步计算
从多个任务的角度来看,任务可以是串行执行的，也可以是并发执行的。从单个任务的角度来看，任务的执行方式可以是同步的(Synchronous )，
如图9-1 ( a)所示;也可以是异步的(Asynchronous )，如图9-1 (b)所示。这里的同步与线程同步机制中的“同步”不是同一个概念。

以同步方式执行的任务，我们称之为同步任务，其任务的发起与任务的执行是在同一条时间线上进行的。
换而言之，任务的发起与任务的执行是串行的。同步任务就好比我们以电话的形式将一个消息通知给朋友的情形:我们先拨打对方的号码（任务的发起)，
只有在电话接通（任务开始执行)之后我们才能够将消息告诉对方（任务执行的过程) ' 。

以异步方式执行的任务，我们称之为异步任务，其任务的发起与任务的执行是在不同的时间线上进行的。
换而言之，任务的发起与任务的执行是并发的。异步任务好比我们以短信的形式将一个消息通知给朋友的情形:
我们只要给对方发送一条短信（任务的发起)便认为已经通知到对方了，而不必关心对方何时阅读这条短信，而实际上对方可能在第二天阅读这条短信（任务开始执行)。

同步方式与异步方式的说法是相对的:同一个任务我们既可以说它是异步任务，也可以说它是同步任务。
假设我们用一个 Runnable实例 task来表示一个任务，如果我们直接调用task.run()来执行该任务，
那么我们就可以称该任务为同步任务;如果我们通过newThread(task).start()调用创建并启动一个专门的工作者线程来执行该任务﹐
或者将该任务提交给一个Executor实例executor执行(即调用executor.execute(task))，那么我们就可以称该任务为异步任务。
同步方式与异步方式的称呼不仅仅取决于一个任务的具体执行方式，还取决于我们的观察角度。
在上述例子中，假设我们将task提交给线程池执行，那么从该任务提交线程（即ThreadPoolExecutor.submit方法的执行线程）的角度来看它是一个异步任务，
而从线程池中的工作者线程（即实际执行该任务的线程)的角度来看该任务则可能是一个同步任务2。

同步任务的发起线程在其发起该任务之后必须等待该任务执行结束才能够执行其他操作，这种等待往往意味着阻塞（ Blocking )，
即任务的发起线程会被暂停，直到任务执行结束。

例如，直接通过InpuStream.read()读取一个文件中的内容就是一个同步任务，在InpuStream.read()调用返回数据前该任务的发起线程会被暂停。
同步任务也并不一定总是会使其发起线程被阻塞，同步任务的发起线程也可能以轮询的方式来等待任务的结束。
所谓轮询( Polling)是指任务的发起线程不断地检查其发起的任务是否执行结束，若任务已执行结束则执行下一步操作，否则继续检查任务，
直到该任务完成。阻塞意味着在同步任务执行结束前，该任务的发起线程并没有在运行(其生命周期状态不为RUNNABLE )，
而轮询意味着在同步任务执行结束前，该任务的发起线程仍然在运行，只不过此时该线程的

主要动作是检查相应的任务是否执行结束。同步任务的发起线程是采用阻塞的方式还是轮询方式来等待任务的结束很大程度上取决于我们使用的API。
例如,使用java.nio.channels.Selector类来编写网络应用程序的服务端代码的时候，我们能够采用轮询的方式来实现等待同步任务的结束，
而多数情况下我们只能够以阻塞方式来实现等待同步任务的结束。单个线程便可以实现同步任务的执行。
在使用单个线程的情况下,多个同步任务只能够以同步的方式执行。

异步任务的发起线程在其发起该任务之后不必等待该任务结束便可以继续执行其他操作，即异步任务的发起与实际执行可以是并发的。
多线程编程本质上是异步的。比如一个线程通过ThreadPoolExecutor.submit(Callable<T>)调用向线程池提交一个任务（任务的发起)，
在该调用返回之后该线程便可以执行其他操作了，而该任务可能在此之后才被线程池中的某一个工作者线程所执行，这里任务的提交与执行是并发的，
而不是串行的。可见,异步任务可以使其发起线程不必因等待其执行结束而被阻塞，即异步任务执行方式往往意味着非阻塞(Non-blocking )。
然而，阻塞与非阻塞只是任务执行方式的一种属性，它与任务执行方式之间并没有必然的关系:同步任务执行方式多数情况下意味着阻塞，
但是它也可能意味着非阻塞（轮询);异步任务执行方式多数情况下意味着非阻塞，但是它也可能意味着阻塞。
例如，如果我们在向线程池提交一个任务之后立刻调用Future.get()来试图获取该任务的处理结果(即ThreadPoolExecutor.submit(someTask).get())，
那么尽管该任务是异步执行的,但是其发起线程仍然可能由于Future.get()调用时该任务尚未被线程池执行结束而被阻塞。
异步任务的执行需要借助多个线程来实现。多个异步任务能够以并发的方式被执行。

注意
阻塞与非阻塞只是任务执行方式(同步/异步)本身的一种属性，它们与任务执行方式之间并未有必然的联系:异步任务既可能是非阻塞的，也可能是阻塞的;
同步任务既可能是阻塞的，也可能是非阻塞的。
同步方式与异步方式的说法是相对的，它取决于任务的执行方式以及我们的观察角度。

同步方式的优点是代码简单、直观，缺点是它往往意味着阻塞，而阻塞会限制系统的吞吐率。异步方式往往意味着非阻塞，因而有利于提高系统的吞吐率。
异步方式的代价是更为复杂的代码和更多的资源投入。例如，以异步方式执行任务需要借助额外的工作者线程,并且还需要对这些工作者线程进行管理(启动、停止等)。


9.2.1实用工具类Executors
第8章我们已经介绍到实用工具类java.util.concurrent.Executors，
它除了能够返回默认线程工厂( Executors.defaultThreadFactory())、
能够将 Runnable 实例转换为Callable 实例(Executors.callable方法)之外，还提供了一些能够返回ExecutorService实例的快捷方法，
如表9-1所示。这些ExecutorService实例往往使我们在不必手动创建ThreadPoolExecutor实例的情况下使用线程池。
cn.locusc.mtia.chapter9\images\表-9-1-Executors提供的能够返回ExecutorService实例的快捷方法.jpg

Executors.newCachedThreadPoolO。该方法的返回值相当于:
new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(0));
即一个核心线程池大小为0，最大线程池大小不受限，工作者线程允许的最大空闲时间( keepAliveTime )为60秒,
内部以SynchronousQueue为工作队列(以下称之为 workerQueue)的一个线程池。
这种配置意味着该线程池中的所有工作者线程在空闲了指定的时间后都可以被自动清理掉。
由于该线程池的核心线程池大小为0，因此提交给该线程池执行的第一个任务会导致该线程池中的第一个工作者线程被创建并启动。
后续继续给该线程池提交任务的时候，由于当前线程池大小已经超过核心线程池大小（0)，
因此ThreadPoolExecutor 此时会将任务缓存到工作队列之中（即调用workerQueue.offer方法)。

SynchronousQueue内部并不维护用于存储队列元素的实际存储空间。一个线程（生产者线程）在执行SynchronousQueue.offer(E)的时候，
如果没有其他线程(消费者线程)因执行SynchronousQueue.take()而被暂停,那么SynchronousQueue.offer(E)调用会直接返回false，
即入队列失败。因此，在该线程池中的所有工作者线程都在执行任务，即无空闲工作者线程的情况下给其提交任务会导致该任务无法被缓存成功。
而ThreadPoolExecutor 在任务缓存失败且线程池当前大小未达到最大线程池大小(这里的最大线程池大小实际上相当于不限）的情况下会创建并启动新的工作者线程。
在极端的情况下，给该线程池每提交一个任务都会导致一个新的工作者线程被创建并启动,而这最终会导致系统中的线程过多,
从而导致过多的上下文切换而使得整个系统被拖慢。因此，Executors.newCachedThreadPool()所返回的线程池适合于用来执行大量耗时较短且提交频率较高的任务。
而提交频率较高且耗时较长的任务（尤其是包含阻塞操作的任务）则不适合用Executors.newCachedThreadPoolO所返回的线程池来执行。

Executors.newFixedThreadPool(int nThreads)。该方法的返回值相当于:
new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
即一个以无界队列为工作队列，核心线程池大小与最大线程池大小均为nThreads且线程池中的空闲工作者线程不会被自动清理的线程池，
这是一种线程池大小一旦达到其核心线程池大小就既不会增加也不会减少工作者线程的固定大小的线程池。因此，这样的线程池实例一旦不再需要，
我们必须主动将其关闭。Executors.newSingleThreadExecutor()。该方法的返回值基本相当于Executors.newFixedThreadPool(1)所返回的线程池。
不过，该线程池并非 ThreadPoolExecutor实例，
而是一个封装了ThreadPoolExecutor实例且对外仅暴露ExecutorService接口所定义的方法的一个ExecutorService实例。该线程池便于我们实现单(多)生
产者一单消费者模式。该线程池确保了在任意一个时刻只有一个任务会被执行，这就形成了类似锁将原本并发的操作改为串行的操作的效果。
因此，该线程池适合于用来执行访问了非线程安全对象而我们又不希望因此而引入锁的任务。该线程池也适合于用来执行IO操作,
因为IO操作往往受限于相应的I/O设备,使用多个线程执行同一种IO操作（比如多个线程各自读取一个文件）可能并不会提高I/O 效率，
所以如果使用一个线程执行IO足以满足要求，那么仅使用一个线程即可，这样可以保障程序的简单性以避免一些不必要的问题（比如死锁）。



