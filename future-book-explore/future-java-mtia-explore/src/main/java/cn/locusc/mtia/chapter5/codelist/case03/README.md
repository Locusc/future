缓冲（ Buffering )是一种常用的数据传递技术。
缓冲区相当于数据源( Source，即数据的原始提供方）与数据使用方( Sink )之间的数据容器。
从这个角度来看，数据源相当于生产者，数据使用方相当于消费者。数据源所提供的数据相当于产品，而缓冲区可被看作产品的容器或者外包装。
在多线程环境下，有时候我们会使用两个(或者更多)缓冲区来实现数据从数据源到数据使用方的移动。
其中一个缓冲区填充满来自数据源的数据后可以被数据使用方进行“消费”，
而另外一个空的(或者已经使用过的）缓冲区则用来填充来自数据源的新的数据。
这里，负责填充缓冲区的是一个线程（生产者线程)，而使用已填充完毕的另外一个缓冲区的则是另外一个线程（消费者线程)。
因此，当消费者线程消费一个已填充的缓冲区时，另外一个缓冲区可以由生产者线程进行填充，从而实现了数据生成与消费的并发。
这种缓冲技术就被称为双缓冲( Double Buffering )。

JDK 1.5中引入的标准库类 java.util.concurrent.Exchanger可以用来实现双缓冲。
Exchanger相当于一个只有两个参与方的 CyclicBarrier。
Exchanger.exchange(V)相当于CyclicBarrier.await()。Exchanger.exchange(V)的声明如下:

public v exchange (v x) throws InterruptedException
其中,V是 Exchanger类的类型参数，参数x和返回值相当于缓冲区。

通常，初始状态下生产者和消费者各自创建一个空的缓冲区。
消费者线程执行Exchanger.exchange(V)时将参数x指定为一个空的或者已经使用过的缓冲区，
生产者线程执行 Exchanger.exchange(V)时将参数x指定为一个已经填充完毕的缓冲区。
比照CyclicBarrier 来说，生产者线程和消费者线程都执行到Exchanger.exchange(V)相当于这两个线程都到达了集合点,
此时生产者线程和消费者线程各自对Exchanger.exchange(V)的调用就会返回。Exchanger.exchange(V)的返回值是对方线程执行该方法时所指定的参数x的值。
因此，Exchanger.exchange(V)的返回就造成一种生产者线程和消费者线程之间交换缓冲区（产品）的效果，
即消费者线程向生产者线程提供(通过指定参数x的值)的是一个空的(或者已经使用过的）的缓冲区，
而生产者线程向消费者线程提供（通过指定参数x的值)的则是一个已经填充完毕的缓冲区。
这就好比当面交易的情况下，交易双方“一手交钱，一手交货”。
这样，生产者线程和消费者线程之间通过不断地交换缓冲区（相当于产品的容器）就实现了将生产者所生产的一个个产品传递给消费者的效果。
因此，Exchanger 从逻辑上可以被看作一种SynchronousQueue，其内部也不维护用于存储产品的存储空间。

在单生产者—单消费者模式中，我们可以考虑使用Exchanger作为传输通道。
例如，在第4章的第2个实战案例（响应延时统计程序，代码见清单4-7）中，
我们也可以使用Exchanger 作为生产者线程（日志文件读取线程）和消费者线程（统计处理线程）之间的传输通道。
为此，我们只需要新建AbstractLogReader 的子类来实现日志读取线程即可，如清单5-13所示。



从双缓冲的角度来看，ExchangerBasedLogReaderThread内部维护了两个类型为RecordSet(参见清单4-8）的缓冲区 nextToFill和 consumedBatch，
前者表示待填充的缓冲区,后者表示填充后已被“消费”过的缓冲区。
ExchangerBasedLogReaderThread.nextBatch()的执行线程（统计处理线程，参见清单4-7）相当于消费者线程，
它提供一个已“消费”过的缓冲区来调用exchanger.exchange(consumedBatch)以获得（交换到)一个新填充的缓冲区。
ExchangerBasedLogReaderThread.publish(RecordSet)的执行线程(日志文件读取线程，即 ExchangerBasedLogReaderThread '实例）相当于生产者线程，
它提供一个新填充完毕的缓冲区来调用exchanger.exchange(recordSet)以获得（交换到)一个待填充的缓冲区。

5.5.5一个还是一批:产品的粒度
在第4章的第2个实战案例（响应延时统计程序，代码见清单4-7）所实现的生产者—消费者模式中，
RecordSet类相当于产品，而一个RecordSet实例可以包含一批日志记录（例如2000条记录)。
因此，该实例中生产者线程（文件读取线程）和消费者线程（统计处理线程)之间传递的产品是一批记录而不是一条记录!
显然，如果该实例以一条日志记录代表一个产品的话，那么由于待统计的日志记录可达上千万条之多,
因此产品在传输通道上的移动操作( put和 take操作）次数将可能达到千万级。而将一批日志记录作为一个产品则可以大幅减少产品在传输通道上的移动次数，
从而可减少相应的开销。这里，一条日志记录可以作为一个产品，而一批日志记录也可以作为一个产品。
这就是产品的粒度( Granularity )。在上述例子中，使用一条日志记录来表示的产品粒度过细，使用一批日志记录来表示的产品粒度较粗。
产品的粒度是一个相对的概念。在问题规模一定的情况下，产品的粒度过细会导致产品在传输通道上的移动次数增大;
产品的粒度稍微大些可以减少产品在传输通道上的移动次数，但是产品所占用的资源也随之增加。
因此，产品粒度的确定是权衡产品在传输通道上的移动次数和产品所占用的资源的结果。



