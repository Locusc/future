下面看一个实战案例。某分布式系统有个告警功能模块。
该模块的主要职责是接收其他模块提交的告警消息，并将这些告警消息通过网络连接上报（发送）到告警服务器上。
该模块中的告警代理(AlarmAgent类,如清单5-1所示)负责与告警服务器建立网络连接,并对外暴露一个sendAlarm方法用于将指定的告警消息上报到告警服务器上。
AlarmAgent内部会维护两个工作者线程:一个工作者线程负责与告警服务器建立网络连接( Socket连接)，我们称该线程为网络连接线程;
另外一个工作者线程负责定时检测告警代理与告警服务器的网络连接状况，我们称该线程为心跳线程。
告警模块还专门维护了一个告警发送线程,该工作者线程通过调用AlarmAgent.sendAlarm(String)将该模块接收到的告警消息上报给告警服务器。

由于告警发送线程执行AlarmAgent.sendAlarm(String)的时候AlarmAgent 与告警服务器的网络连接可能尚未建立完毕，
或者中途由于一些故障（比如告警服务器宕机)连接已经中断，因此该线程需要等待AlarmAgent 与告警服务器的连接完毕或者恢复连接之后才能上报告警消息，
否则会导致告警上报失败。这里，我们可以使用wait/notify实现一套等待/通知的机制:告警发送线程在上报告警消息前必须等待，
直到AlarmAgent 与告警服务器的连接成功建立或者恢复;心跳线程在检测到网络连接恢复之后通知告警发送线程，如清单5-1所示。


AlarmAgent的实例变量connectedToServer用来表示告警代理与告警服务器的网络连接状态。
sendAlarm方法在调用doSendAlarm方法将告警消息上报到告警服务器之前会先判断connectedToServer的值。
若connectedToServer值为false（表示网络连接未建立或者已中断)，那么告警发送线程会调用AlarmAgent.wait()来暂停当前线程。
这里，告警发送线程就是一个等待线程，布尔表达式“connectedToServer”构成了该等待线程的保护条件。
心跳线程在检测到网络连接中断的情况下，会调用connectToServer方法重新创建一个网络连接线程实例来重建网络连接。
网络连接线程在其建立与告警服务器的网络连接之后会调用AlarmAgent.notify()来通知告警发送线程。这里，网络连接线程相当于通知线程。
该案例中的等待线程和通知线程是同步在AlarmAgent实例之上的。
