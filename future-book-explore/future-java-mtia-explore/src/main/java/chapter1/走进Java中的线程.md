### 第一章 走进Java世界中的线程
#### 1.1 进程、线程与任务

进程(Process)是程序的运行实例
清单1-1 一个简单的 Java 程序(chapter1.codelist.SimpleJavaApp)

linux系统查看进程命令
ps -ef | grep "SimpleJavaApp" | grep - v "grep"

上述命令的输出类似如下：
viscent 8037 6596 0 19 : 24 pts/6 00:00:00 java chapter1.codelist.SimpleJavaApp

进程是程序是向操作系统申请资源(如内存空间和文件句柄)的基本单位
线程(Thread)是进程中可独立执行的最小单位
例如, 一个实现从服务器上下载大文件功能的程序为了提高其文件下载效率可以使用多个线程,
这些线程各自独立地从服务器上下载大文件中的一段数据.

一个进程可以包含多个线程. 同一个进程中的所有线程共享该进程中的资源如内存空间和文件句柄等
进程和线程之间的关系, 就好比一个营业中的饭店与其正在工作的员之间的关系。
一个营业中的饭店对外为顾客提供餐饮服务, 而这种服务最终是通过该饭店
的员工实现的, 这些工作中的员工有的在迎宾, 有的在烹调, 有的给顾客上菜
们在其工作过程中共享该饭店的资源, 如食材、餐具、清洁用具等

线程所要完成的计算就被称为任务, 特定的线程总是在执行着特定的任务.
任务代表线程所要完成的工作, 它是一个相对的概念

#### 1.2 多线程编程简介

##### 1.2.1 什么是多线程编程
函数式编程(Functional Programming)中的函数是基本抽象单位, 面向对象编程中的
类(class)是基本抽象单位. 类似地, 多线程编程就是以线程为基本抽象单位的一种编
程范式(Paradigm). 但是, 多线程编程又不仅仅是使用多个线程进行编程那么简单, 其
自身又有其需要解决的问题. 当然, 多线程编程和面向对象编程是可以相容的, 即我们
可以在面向对象编程的基础上实现多线程编程, 事实上 Java 平台中的一个线程就是一个对象

##### 1.2.2 为什么使用多线程
Web服务器(如Apache Tomcat)常常在同一时间内会收到多个HTTP请求, 为了避多
个请求的处理快慢影响到其他请求的处理, 绝大多数服务器都会采用 些专门的线程
(工作者线程)负责请求处理, 这些线程各自处理分配给它的请求, 从而使得一个请求处
理的快慢不会对其他请求的处理产生影响(当然, 这里的"不影响"是相对的). 这有点
像快餐店在点餐顾客多的情况下多开几条点餐线, 以减少每个顾客的等待时间.

#### 1.3 Java线程API简介
Java标准库类java.lang.Thread就是Java平台对线程的实现. Thread类或其子类的一
个实例就是一个线程

##### 1.3.1 线程的创建、启动与运行
每个线程都有其要执行的任务. 线程的任务处理逻辑可以在Thread类的run实例方
法中直接实现或者通过该方法进行调用, 因此run方法相当于线程的任务处理逻辑的入口
方法, 它由Java虚拟机在运行相应线程时直接调用, 而不是由应用代码进行调用

运行一个线程实际上就是让Java虚拟机执行该线程的run方法, 从而使相应线程的任
务处理逻辑代码得以执行. 为此, 我们首先要启动线程Thread类的start方法的作用是启
动相应的线程. 启动一个线程的实质是请求Java虚拟机运行相应的线程, 而这个线程具
体何时能够运行是由线程调度器(Scheduler)决定的. 因此, start方法调用结束并不意
味着相应线程已经开始运行, 这个线程可能稍后才被运行, 甚至也可能永远不会被运行.

Thread类的两个常用构造器Thread()和Thread(Runnable target). 相应地, Java
语言中创建线程有两种方式。 一种是使用上述第 个构造器: 定义Thread类的子类, 在该
子类中覆盖(Override)run方法并在该方法中实现线程任务处理逻辑; 另一种是使用上述
第2个构造器:创建一个java.lang.Runnable接口的实例, 并在该实例的run方法中实现任
务处理逻辑, 然后以改Runnable接口实例作为构造器的参数直接创建(new)一个Thread类的实例

在Java平台中, 每个线程均可以有自己的名字, 这个名字便于我们(人)区分不同的线程
假设我们要创建一个处理任务为打印一行欢迎信息的简单线程
如清单1-2和清单1-3所示的代码分别展示了用上述两种方法创建相应的线程

清单1-2 以定义Thread类子类的方式创建线程
chapter1.codelist.WelcomeApp.threadTest1
```
1.Welcome! I`m main.
2.Welcome! I`m Thread-0.
```

清单1-3 以创建Runnable接口实例的方式创建线程
```
1.Welcome! I`m main.
2.Welcome! I`m Thread-0.
```

不管是采用哪种方式创建线程, 一旦线程的run方法执行(由Java虚拟机调用)结束,
相应的线程的运行也就结束了. 当然, run方法执行结束包括正常结束(run方法返回)以
及代码中抛出异常而导致的中止. 运行结束的线程所占用的资源（如内存空间）会如同其
Java对象一样被Java虚拟机垃圾回收

线程属于"一次性用品", 我们不能通过重新调用一个已经运行结束的线程的start
方法来使其重新运行. 事实上, start方法也只能够被调用一次, 多次调用同一个Thread
实例的start方法会导致其抛出IllegalThreadStateException异常

任意一段代码都可以通过调用Thread.currentThread()来获取这段代码的执行线程

清单1-4 应用代码直接调用线程的run方法(避免这样操作)
chapter1.codelist.WelcomeApp.threadTest3
线程的run方法总是由Java虚拟机直接调用的. 尽管如此, Java语言并不阻
止我们直接调用run方法, 这是因为: 首先, 线程在Java平台中也是一个对象, 其次毕竟
run方法也是一个public但是, 多数情况下我们不能这样做, 因为这样做有违创建
线程(对象)的初衷. 例如, 运行如清单1-4所示的程序(改自清单 1-3 ), 我们可以看到
该程序的输出类似如下:
```
2.Welcome! I`m main.
1.Welcome! I`m main.
2.Welcome! I`m Thread-0.
```
因此, 如果我们没有启动线程, 而是在应用代码中直接调用线程的run方法的话, 那么这个
线程的run方法其实运行在当前线程(即run方法的调用方代码的执行线程)之中而不是
运行在其自身线程之中, 从而违背了创建线程的初衷.

##### 1.3.2 Runnable接口
Runnable接口只定义了一个方法.
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

Runnable接口可以被看作对任务进行的抽象, 任务的处理逻辑就体现在run方法之中
Thread类实际上是Runnable接口的一个实现类, 其对Runnable接口的实现如图1-1所示.
```java
public class Thread implements Runnable {
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}
```
Thread类的run方法中实现的逻辑是如果target不为null, 那么就调用target.run(),
否则它什么也不做, 其中, 实例变量target类型为Runnable如果相应的线程实例是通
过构造器Thread(Runnable target)创建的, 那么target的值为构造器中的数值, 否则target
的值为null. 因此, Thread类所实现的任务处理逻辑是要么什么也不做(target为null),
要么直接执行target所引用的Runnable实例所实现的任务处理逻辑. Thread类的run方法
的这种处理逻辑决定了创建线程的两种方式: 一种是在Thread子类的 run方法中直接实
现任务处理逻辑, 另一种是在一个Runnable实例中实现任务处理逻辑, 诙逻辑由Thread
类的run方法负责调用

扩展阅读: 线程两种创建方式的区别
从面相对象编程的角度来看: 
第一种创建方式(创建Thread类的子类)是一种基于
继承(Inheritance)的技术, 第一种创建方式(以Runnable接口实例为构造器参数直接通
new创建Thread实例)是一种基于组合(Composition)的技术. 由于组合相对继承来
说, 其类和类之间的搞合性(Coupling)更低, 因此它也更加灵活, 一般我们认为组合是
优先选用的技术

从对象共享的角度来看:
第一种创建方式意味着多个线程实例可以共享同一个
Runnable在某些情况下这可能导致程序的运行结果出乎我们的意料. 例如, 在如清单
1-5所示的程序中, 我们分别以第一种和第二种方式各自创建了若干线程, 假设这个程
序运行在处理器个数为4的主机上, 那么该程序的输出中的"CountingTask":"后面跟的数
字最大的数也可能仍小于800(=2*4*100), 而"CountingTread:"后面跟的数字始终都
是100. 对于这个结果的解释会涉及我们将在第2章中提到的竞态和线程安全这两个概念
清单1-5 线程的两种创建方式的区别
chapter1.codelist.ThreadCreationCmp

从对象创建成本的角度来看:
Java中的线程实例是一个"特殊"的Runnable实例,
因为在创建它的时候Java虚拟机会为其分配调用栈空间,内核线程等资源. 因此, 创建
一个线程实例比起创建一个普通的Runnable实例来说, 其成本要相对昂贵一点. 所以,
如果创建Runnable实例再将其作为方法参数传递给其他对象使用
(JDK标准库中有不少API都使用了Runnable接口)
而不必利用它来创建相应的线程(即第二种线程创建方式)
即可满足我们的计算需要, 那么就不要创建线程实例

##### 1.3.3 线程属性


