死锁是线程的一种常见活性故障。
如果两个或者更多的线程因相互等待对方而被永远暂停（线程的生命周期状态为 BLOCKED 或者 WAITING)，那么我们就称这些线程产生了死锁( Deadlock )。
由于产生死锁的线程的生命周期状态永远是非运行状态，因此这些线程所要执行的任务也永远无法进展。
死锁产生的一种典型情形是线程A在持有锁L的情况下申请锁L，而线程B在持有L2的情况下申请L，A只有在获得并释放L后才会释放L，而B只有在获得并释放L,后才会释放L。
也就是说，A和B各自都在持有一个锁(分别为L,和L)的情况下去申请对方持有的另外一个锁(分别为Lz和L)，而A和B释放其持有的锁的前提又都是先获得对方持有的另外一个锁,
因此这两个线程最终都无法获得它们申请的另外一个锁，两个线程都处于无限等待的状态，即产生了死锁，如图7-1所示。
死锁好比鹂蚌相争故事中的情形:醇啄住蚌的肉，蚌夹住鹂的嘴。葫对蚌说;“你先放开我的嘴我便不啄你的肉。
”而蚌对鹂说:“你先放开我的肉我便不夹你的嘴。”于是最后谁也不放开谁!

有关死锁的一个经典问题就是哲学家就餐问题(Dining Philosophers Problem ) '。
5个沉默寡言的哲学家相约去了一家“另类”的中餐馆聚餐。
哲学家们围坐在一张大圆桌上，每个座位前面各有一个饭碗，每个饭碗之间都有一根（而不是一双!)筷子( Chopstick ),
桌子中间有一碗怎么都吃不完的米饭，如图7-2所示。
每个哲学家( Philosopher )就这么各自对着桌上的米饭坐着，他们要么在思考，要么在吃饭，彼此之间也不交流。
吃饭的时候，每个哲学家总是先拿起自己左手边的筷子，再拿起自己右手边的筷子，只有手上持有一双筷子的时候哲学家才能够吃饭。
哲学家吃着吃着会放下手中的筷子进行思考，思考完毕之后又接着吃饭，如此这般地在思考与吃饭之间反复。

我们不难写出一个模拟哲学家就餐问题的程序,但是这个程序很可能因为死锁而导致所有哲学家都无法吃饭。
为什么呢?我们不妨将这个问题做一下简化:在保持问题的其他约束不变的情况下，我们假设聚餐的哲学家只有两个( Philosopher，和 Philosopherz )，
他们面对面地坐在一张小方桌上，桌面中央有两根筷子( Chopstick,和 Chopstickz )。
经过这样的简化，不难想象在两个哲学家同时试图吃饭的时候很可能出现这样的情形:一个哲学家（哲学家 Philosopherj)眼明手快拿起了其左手边的筷子，
而当他准备拿起其右手边的筷子时，另外一个哲学家(Philosopherz)也恰好拿起了其( Philosopherz)左手边的筷子。
由于一个哲学家的右手边恰是其相邻的另外一个哲学家的左手边，因此 Philosopher,拿起的这根筷子恰是 Philosopher,要拿起的那根。
此时，每个哲学家都仅拿到一根筷子，而他们都坚持只有拿到对方手上的筷子以便吃饭，才肯放下自己手中的筷子。
我们不难看出这种情形正好符合前文提到的死锁的一个典型情形。如果把每个哲学家看作一个线程(哲学家线程)，
那么由于筷子的数量等于哲学家数量而不是哲学家数量的两倍，因此筷子可以被看作线程间的共享资源。
显然筷子是一个独占资源(一根筷子无法同时被两个哲学家使用)，因此哲学家线程在访问这些资源的时候就需要加锁。
所以，简化后的问题就相当于一个线程( Philosophery)在持有一个锁( Chopstick,对应的内部锁）的情况下去申请另外一个锁( Chopstick对应的内部锁)，
而另外一个线程（ Philosopherz)也在持有一个锁( Chopstick,对应的内部锁）的情况去申请另外一个锁( Chopstick对应的内部锁)。
可见，简化后的问题是有可能出现死锁的。接下来，我们将简化后的问题推广到原问题，那么不难想象原问题可能出现类似的情形:
由于每个哲学家右手边的筷子正是其右手边哲学家的左手边的筷子,
因此在5个哲学家同时开始吃饭的情况下是有可能出现每个哲学家刚刚拿起其左手边筷子之后准备拿起其右手边的筷子时，
这根(右手边的)筷子恰好被右手边的哲学家拿起,于是每个哲学家都是左手拿着一根筷子而在等待其右手边的哲学家放下其手中的筷子。
由于每个哲学家都坚持只有拿到两根筷子并吃过饭之后才肯放下手中的筷子，
因此这种情形最终演变成任何一个哲学家实质上都是在等待自己放下其左手的筷子才能拿到其右手边的筷子，
而每个哲学家放下其左手的筷子的前提又是先拿到其右手边的筷子，显然这也会产生死锁!
                                          
我们不难写出一个模拟哲学家就餐问题的程序来验证上述分析。把该问题中的哲学家看作线程，
我们可以使用一个抽象类AbstractPhilosopher对哲学家进行抽象，如清单7-1所示。
AbstractPhilosopher类的抽象方法 eat抽象了哲学家吃饭的完整动作,包括吃饭本身以及准备动作（拿起筷子）和结束动作（放下筷子)。
而 AbstractPhilosopher.doEat()则模拟了吃饭这个动作本身。吃饭动作的具体实现，
即如何在 AbstractPhilosopher.eat()中组织好准备动作、吃饭动作本身以及结束动作这三者之间的关系则由 AbstractPhilosopher类的子类来负责。
AbstractPhilosopher.run()则代表哲学家总是在思考与吃饭之间反复。

<死锁产生的条件和规避>
哲学家就餐问题反映了产生死锁的必要条件，线程一旦产生死锁，那么这些线程及相关的资源将满足如下全部条件“。

资源互斥（Mutual Exclusion)。涉及的资源必须是独占的，即每个资源一次只能够被一个线程使用。
例如，哲学家就餐问题中的筷子（或者使用筷子时所需持有的锁）可被看作独占的资源。

资源不可抢夺（No Preemption)。涉及的资源只能够被其持有者（线程）主动释放，而无法被资源的持有者和申请者之外的第三方线程所抢夺（被动释放）。
例如，哲学家就餐问题中的筷子只能由持有该筷子的哲学家（线程）主动放下（释放）。

占用并等待资源(Hold and Wait )。涉及的线程当前至少持有一个资源（资源A)并申请其他资源（资源B)，而这些资源（资源B）恰好被其他线程持有。
在这个资源等待的过程中，线程并不释放其已经持有的资源。例如，哲学家就餐问题中一个哲学家(线程)左手拿着筷子(资源A)而等待其右手边的筷子(资源B)，
这根筷子恰好被其右手边的哲学家（线程）拿起（持有)。并且，等待其他哲学家手上的筷子的哲学家并不放下自己手中的筷子。

循环等待资源(Circular Wait)。涉及的线程必须在等待别的线程持有的资源，而这些线程又反过来在等待第1个线程所持有的资源。
比如有一组线程{T，T2，…，T}以及一组资源{R，R，…，Rw}，T在等待R,而R被T,持有，T,在等待R,而R,被T,持有，……，T,在等待R,而R,被T持有，
这些线程就满足了循环等待资源这个条件。例如，哲学家就餐问题中第1个哲学家（线程）在等待第2个哲学家左手持有的筷子（资源），
第2个哲学家（线程)在等待第3个哲学家左手持有的筷子（资源），……，第5个哲学家在等待第1个哲学家左手持有的筷子。

这些条件是死锁产生的必要条件而非充分条件，也就是说只要产生了死锁，那么上面这些条件一定同时成立，但是上述条件即使同时成立也不一定就能产生死锁。
因此，死锁和其他的多线程相关的问题（比如可见性问题）类似，它并不是必然出现的!上述几个条件并非完全独立，其中“循环等待资源”就可能蕴含了“占用并等待资源”，
而“占用并等待资源”可能是“循环等待资源”的基础，但却不一定意味着“循环等待资源”。

我们可以把锁看作一种资源，这种资源正好符合“资源互斥”和“资源不可抢夺”的要求。
那么，可能产生死锁的代码特征就是在持有一个锁的情况下去申请另外一个锁，这通常意味着锁的嵌套，如图7-3所示。

