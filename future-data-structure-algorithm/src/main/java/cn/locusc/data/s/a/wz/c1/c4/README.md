算法和算法分析
1.算法的定义
    对特定问题求解方法和步骤的一种描述, 它是指令的有限序列. 其中每个指令表示一个或多个操作’
    简而言之, 算法就是解决问题的方法和步骤
    Step1: ...
    Step2: ...
    Step3: ...
    算法求一元二次方程的根
    1.输入方程的系数a,b,c.
    2.判断a是否等于零, 如果等于零, 则提示不是一元二次方程, 不等于零, 则执行第三步
    3.计算d=b^2-4ac
    4.判断d, 如果d等于零, 计算并输出两个相等实根. 如果d小于零,输出没有实根,
    如果d大于零, 输出两个不等实根

2.算法与程序
    算法是解决问题的一种方法或一个过程, 考虑如何将输入转换成输出, 一个问题可以有多种算法
    程序是用某种程序设计语言对算法的具体实现, 程序=数据结构+算法
    数据结构通过算法实现操作
    算法根据数据结构设计程序
    
3.算法特性: 一个算法必须具备以下五个重要特征
    1.有穷行: 一个算法必须总是在执行有穷步之后结束, 且每一步都在有穷时间内完成
    2.确定性: 算法中的每一条指令必须有确切的含义, 没有二义性, 在任何条件下,
    只有唯一的一条执行路径, 即对于相同的输入只能得到相同的输出
    3.可行性: 算法是可执行的, 算法描述的操作可以通过已经实现的基本操作执行有限次来实现
    4.输入: 一个算法有零个或多个输入
    5.输出: 一个算法有一个或多个输出
    
4.算法设计要求
    1.正确性: 算法满足问题要求, 能正确解决问题
    算法转化为程序后注意: 通常第三层意义上的正确性作为衡量一个算法是否合格的标准
        1.程序中不含语法错误
        2.程序对于几组输入数据能够的得出满足要求的结果
        3.程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够的得出满足要求的结果
        4.程序对于一切合法的输入数据都能得出满足要求的结果
    2.可读性
        1.算法主要为了人的阅读和交流, 其次才是为计算机执行, 因此算法应该易于人的理解
        2.另一方面, 晦涩难度的算法易于隐藏较多错误而难以调试
    3.健壮性
        1.指当输入非法数据时, 算法恰当的做出反应或进行相应处理, 而不是产生莫名其妙的输出结果
        2.处理出错的方法, 不应是中断程序的执行, 而应是返回一个表示错误或错误性质的值, 以便在更高的抽象
        层次上进行处理
    4.高效性
        要求花费尽量少的时间和尽量低的存储需求
        
5.算法分析
1.一个好的算法首先要具备正确性, 然后是健壮性, 可读性, 在几个方面来满足的情况下,
主要考虑算法的效率, 高低来评判不同算法的优劣程度.
2.算法效率以下两个方面来考虑(时间效率和空间效率有时候是矛盾的)
    1.时间效率: 指的是算法所耗费的时间;
    2.空间效率: 指的是算法执行过程中所耗费的存储空间;
3.算法时间效率的度量
    算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量
    两种度量方法
    1.事后统计
        将算法实现, 测算其时间和空间开销
        缺点: 编写程序实现算法将花费较多的时间和精力, 所得实验结果依赖于计算机的
        软硬件等环境因素, 掩盖算法本身的优劣
    2.事前分析
        对算法所消耗资源的一种估算方法
        1.一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于
        计算机执行一种简单的操作(如赋值, 比较, 移动等)所需的时间与算法中进行的
        简单操作次数乘积(算法运行时间=一个简单操作所需的时间 * 简单操作次数)
        2.也即算法中每条语句的执行时间之和
        算法运行时间= ∑每条语句执行次数(又称为语句频度) * 该语句执行一次所需的时间
        算法运行时间= ∑每条语句频度 * 该语句执行一次所需的时间
            每条语句执行一次所需的时间, 一般是随机器而异的, 取决于机器的指令性能、速度
        以及编译的代码质量, 是由机器本身软硬件环境决定的, 它与算法无关
            所以, 我们可假设执行每条语句所需的时间均为单位时间, 此时对算法的运行时间的
        讨论该算法中所有语句的执行次数, 即频度之和了.
            这可以独立于不同机器的软硬件环境来分析算法的时间性能
```java
public class test () {
    /**
     * 两个n*n矩阵相乘的算法可描述为
     * 我们把算法所耗费的时间定义为该算法中每条语句的频度之和, 则上述算法的时间消耗为
     * T(n) = 2n^3 + 3n^2 + 2n + 1 
     * n->趋近于无穷大时, T(n)/n^3 -> 2, 这表示n充分大时, T(n)与n^3时同阶或同数量级,
     * 引入大"O"记号, 则T(n)可记作: T(n)=O(n^3) 这就是求解矩阵相乘问题的算法的渐进时间复杂度
     */
    public void test() {
        for(i=1; i<=n; i++) { // n + 1
            for(int j = 0; j <= n; j++) { // n*(n+1)
               c[i][j] = 0; // n*n
               for(int k = 0; k < n; k++) { // n*n*(n+1)
                  // 一般情况下, 不必计算所有操作的执行次数, 而只考虑算法中
                  // 基本操作执行的次数(最高次项), 它是问题的规模n的某个函数, 用T(n)表示 
                  c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n*n*n 基本操作
               }
            }
        }
    }
}
```
6.算法时间复杂度的渐进表示法
1.为了方便比较不同算法的时间效率, 我们仅比较它们的数量级
例如: 两个不同的算法, 时间消耗分别是:
    T1(n) = 10n^2(相较于后面这个算法的数量级更小, 所以更好) 与 T2(n) = 5n^3     
2.若有某个辅助函数f(n), 使得当n趋近于无穷大时, T(n)/f(n)的极限值为不等于零的常数,
则称f(n)是T(n)的同数量级函数. 记作T(n)=O(f(n)), 称O(f(n))为算法的渐进时间复杂度
(O是数量级的符号), 简称时间复杂度

7.算法时间复杂度定义
基本语句:
    1.算法中重复执行次数和算法的执行时间成正比的语句
    2.对算法运行时间的贡献最大
    3.执行次数最多

算法中基本语句重复执行的次数是问题规模n的某个函数f(n), 算法的时间量度记作: T(n)=O(f(n))
它表示随着n的增大,算法执行的时间的增长率和f(n)的增长率相同, 称渐进时间复杂度
数学符号"O"的定义为:
若T(n)和f(n)是定义在正整数集合上的两个函数, 则T(n)=O(f(n))表示存在正的常数C和n0,
使得当n>=n0时都满足0<=T(n)<=Cf(n)

n越大算法的执行时间越长
排序: n为记录数
矩阵: n为矩阵的阶数
多项式: n为多项式的阶数
集合: n为元素个数
树: n为树的结点个数
图: n为图的顶点数或边数

8.分析算法时间复杂度的基本方法
定理: 忽略所有的低次幂项和最高次幂系数, 体现出增长率的含义
1.找出语句频度最大的那条语句作为基本语句
2.计算基本语句的频度得出问题规模n的某个函数f(n)
3.取其数量级用符号"O"表示
```java
public class test{

    /**
     * f(n) = n(n + 1)
     * T(n) = O(n^2)
     * 时间复杂度是由嵌套最深层语句的频度决定的
     */
    public void test() {
        int x=0; y=0; // 1
        for(int k = 0; k < n; k++) { // n+1
          x++; // n
        }
        for(int i = 0; i < n; i++) { // n+1
          for(int j = 0; j < n; j++) { // n(n+1)
            y++; // n*n
          }
        }
    }
}
```

9.算法时间复杂度计算
1.最坏时间复杂度: 指在最坏情况下, 算法时间复杂度
2.平均时间复杂度: 指在所有可能输入实例在等概率出现的情况下, 算法的期望运行时间
3.最好时间复杂度: 指在最好情况下, 算法的时间复杂度
一般总是考虑在最坏情况下的时间复杂度, 以保证算法的运行时间不会比它更长

对于复杂的算法, 可以将它分成几个容易估算的部分, 然后利用大O加法法则和乘法法则
计算算法的时间复杂度

10.算法时间效率的比较
当n取得很大时, 指数时间算法和多项式时间算法在所需时间上非常悬殊

11.渐进空间复杂度
1.空间复杂度: 算法所需存储空间的度量
    记作: S(n)=O(f(n))
    其中n为问题的规模(或大小)
2.算法要占据的空间
    1.算法本身要占据的空间, 输入/输出, 指令, 常数, 变量等
    2.算法要使用的辅助空间

12.算法空间复杂度分析例题
```java
public class test{

    /**
     * f(n) = n(n + 1)
     * T(n) = O(n^2)
     * 时间复杂度是由嵌套最深层语句的频度决定的
     */
    public void test() {
        // S(n)=O(1)
        for(int i = 0; i < n/2; i++) {
            t=a[i];
            a[i]=a[n-i-1];
            a[n-n-1]=t;
        }

        // S(n)=O(n)
        for(int i = 0; i < n; i++) {
            b[i]=a[n-i-1];
            a[i]=b[i];
        }
    }
}
```
    


